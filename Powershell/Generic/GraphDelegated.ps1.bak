# Reference the variables script
$scriptPath = Join-Path $PSScriptRoot "psvariables.ps1"
if (Test-Path $scriptPath) {
    . $scriptPath
    Write-Host "Variables loaded successfully"
} else {
    Write-Error "Required script not found: $scriptPath"
    exit 1
}

# Load required assemblies
try {
    $abstractionsPath = Join-Path (Split-Path $msalPath) "Microsoft.IdentityModel.Abstractions.dll"
    Add-Type -Path $abstractionsPath
    Add-Type -Path $msalPath
    Write-Host "MSAL assemblies loaded successfully"
} catch {
    Write-Error "Failed to load assemblies: $_"
    Write-Error "MSAL Path: $msalPath"
    Write-Error "Abstractions Path: $abstractionsPath"
    exit 1
}

$authority = "https://login.microsoftonline.com/$tenantId"
$redirectUri = $AppIDGraphDelegatedUri  # Using the URI from psvariables.ps1
$scopes = [string[]]@("https://graph.microsoft.com/Mail.Read")  # Cast as string array

Write-Host "Initializing authentication with:"
Write-Host "Authority: $authority"
Write-Host "Redirect URI: $redirectUri"
Write-Host "Requested Scope: $($scopes[0])"

# Token cache setup
$tokenCachePath = Join-Path $PSScriptRoot "token_cache.json"

# Create token cache helper class
$tokenCache = @'
using Microsoft.Identity.Client;
using System;
using System.IO;
using System.Security.Cryptography;

public class TokenCacheHelper
{
    private static readonly string CachePath;
    private static readonly object FileLock = new object();
    
    public static void EnableSerialization(ITokenCache tokenCache)
    {
        tokenCache.SetBeforeAccess(BeforeAccessNotification);
        tokenCache.SetAfterAccess(AfterAccessNotification);
    }
    
    private static void BeforeAccessNotification(TokenCacheNotificationArgs args)
    {
        lock (FileLock)
        {
            if (File.Exists(CachePath))
            {
                var data = File.ReadAllBytes(CachePath);
                args.TokenCache.DeserializeMsalV3(data);
            }
        }
    }
    
    private static void AfterAccessNotification(TokenCacheNotificationArgs args)
    {
        if (args.HasStateChanged)
        {
            lock (FileLock)
            {
                var data = args.TokenCache.SerializeMsalV3();
                File.WriteAllBytes(CachePath, data);
            }
        }
    }
    
    static TokenCacheHelper()
    {
        CachePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "token_cache.json");
    }
}
'@

# Compile the token cache helper
Add-Type -TypeDefinition $tokenCache -ReferencedAssemblies $msalPath

# Create the MSAL client application
try {
    $builder = [Microsoft.Identity.Client.PublicClientApplicationBuilder]::Create($AppIDGraphDelegated)
    $builder = $builder.WithAuthority($authority)
    $builder = $builder.WithRedirectUri($redirectUri)
    $app = $builder.Build()

    # Enable token caching
    [TokenCacheHelper]::EnableSerialization($app.UserTokenCache)

    Write-Host "`nChecking for cached token..."
    try {
        # Try to get token silently first
        $result = $app.AcquireTokenSilent($scopes, "").ExecuteAsync().GetAwaiter().GetResult()
        Write-Host "Using cached token."
    } catch {
        Write-Host "No valid cached token found. Attempting to acquire token interactively..."
        $result = $app.AcquireTokenInteractive($scopes).ExecuteAsync().GetAwaiter().GetResult()
    }
    
    Write-Host "Token acquired successfully!"
    Write-Host "Access Token: $($result.AccessToken.Substring(0,50))..."  # Show first 50 chars only
    Write-Host "Token Expires: $($result.ExpiresOn.LocalDateTime)`n"

    # Set up Graph API headers
    $headers = @{
        "Authorization" = "Bearer $($result.AccessToken)"
        "Content-Type" = "application/json"
    }

    # Simple function to call Graph API
    function Invoke-GraphAPI {
        param (
            [string]$Endpoint
        )
        $uri = "https://graph.microsoft.com/v1.0$Endpoint"
        $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get
        return $response
    }

    # Get user's messages
    try {
        Write-Host "Fetching messages from your mailbox..."
        $queryParams = @(
            "`$top=10",
            "`$select=subject,receivedDateTime,from,isRead",
            "`$orderby=receivedDateTime desc"
        )
        $messages = Invoke-GraphAPI -Endpoint "/me/messages?$($queryParams -join '&')"

        # Display messages
        Write-Host "`nLatest emails:`n"
        foreach ($message in $messages.value) {
            $readStatus = if ($message.isRead) { "Read" } else { "Unread" }
            $sender = $message.from.emailAddress.address
            $subject = if ($message.subject) { $message.subject } else { "(No Subject)" }
            $received = try {
                [DateTime]::Parse($message.receivedDateTime).ToLocalTime().ToString("MM/dd/yyyy HH:mm")
            } catch {
                $message.receivedDateTime
            }

            Write-Host "[$readStatus] $received"
            Write-Host "From: $sender"
            Write-Host "Subject: $subject"
            Write-Host "-------------------"
        }

        # Display paging information if available
        if ($messages.'@odata.nextLink') {
            Write-Host "`nMore messages available. Use `$skiptoken to fetch next page."
        }

    } catch {
        Write-Error "Error fetching messages: $_"
    }

} catch {
    Write-Error "Authentication Error: $_"
    Write-Host "`nDetailed error information:"
    Write-Host $_.Exception.Message
    if ($_.Exception.InnerException) {
        Write-Host "Inner Exception: $($_.Exception.InnerException.Message)"
    }
    exit 1
}

